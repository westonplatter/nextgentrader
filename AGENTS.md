<!-- This file was auto-generated by aps (https://github.com/westonplatter/aps) -->

# NextGenTrader

This is a agentic project enabling one person to operate as an quick and nimble trading desk.

## Docs Index Rule

If any `docs/*.md` file is added, modified, renamed, or deleted (excluding `docs/_index.md`), update `docs/_index.md` in the same change.

`docs/_index.md` has two sections — place the entry in the right one:

- **Project Docs** — runbooks, how-tos, and reference material.
- **Specs** — architecture specs and design proposals (files prefixed `spec-`).

## Codebase Survey

### Repository Layout

- `src/`: Python backend application code (current import root is `src`).
- `scripts/`: operator-facing workflows and broker/database utilities.
- `alembic/` + `alembic.ini`: database migrations for Postgres schema.
- `frontend/`: React + Vite UI for portfolio/positions views.
- `docs/`: runbooks and architecture notes.
- `Taskfile.yaml`: common dev commands for API, frontend, and migrations.

### Primitives

- `src/db.py`: pure-ish DB URL and SQLAlchemy engine builders (`get_database_url`, `get_engine`).
- `src/utils/ibkr_account.py`: account masking helper (`mask_ibkr_account`) for safer logs.
- `scripts/execute_cl_buy_or_sell_continous_market.py`: contains many small parsing/formatting primitives (`parse_float`, `parse_contract_expiry`, `format_money`) used by the order workflow.

### Components

- `src/models.py`: SQLAlchemy `Base` and `Position` entity (single source for table structure in app code).
- `src/schemas.py`: Pandera DataFrame schema for position validation shape.
- `src/api/deps.py`: FastAPI DB session dependency component (`get_db`).
- `src/api/routers/positions.py`: API component that maps DB `Position` rows to response model and exposes `/positions`.
- `frontend/src/components/PositionsTable.tsx`: UI component fetching and rendering `/api/v1/positions`.

### Services

- `scripts/setup_db.py`: service entrypoint to create DB (if needed) and run Alembic migrations.
- `scripts/download_positions.py`: service entrypoint to connect to IBKR TWS and upsert live positions into Postgres.
- `scripts/execute_cl_buy_or_sell_continous_market.py`: trade execution service for CL front-month market orders with confirmation + what-if checks.
- `scripts/test_tws_connection.py`: connectivity/health service for IBKR API session checks.
- `src/api/main.py`: FastAPI service entrypoint (`task api` or `uv run uvicorn src.api.main:app --reload --port 8000`).
- `frontend/` dev server: UI service (`task frontend` or `npm run dev` in `frontend/`).

### End-to-End Workflow (Current)

1. Start IBKR TWS or Gateway.
2. Run `scripts/setup_db.py` to ensure DB + migrations are current.
3. Run `scripts/download_positions.py` to ingest broker positions.
4. Run backend API (`src/api/main.py`) and frontend (`frontend/`).
5. Use `scripts/execute_cl_buy_or_sell_continous_market.py` for live order execution.

### Key Files By Concern

- Broker integration: `scripts/download_positions.py`, `scripts/test_tws_connection.py`, `scripts/execute_cl_buy_or_sell_continous_market.py`
- Data model/storage: `src/models.py`, `src/db.py`, `alembic/versions/20260217221407_create_positions_table.py`
- API surface: `src/api/main.py`, `src/api/routers/positions.py`
- UI surface: `frontend/src/App.tsx`, `frontend/src/components/PositionsTable.tsx`
- Ops docs: `docs/download-positions.md`, `docs/execute-future-cl-order-script.md`, `docs/secrets-using-1password.md`

### Active Architecture Direction

- Planned migration to installable internal app package layout: `docs/spec-installable-internal-app-layout.md`.
- Target state is `src/ngtrader/...` imports (replacing `from src...`) while staying installable via uv.

## Python

### Verifying Code

- Never run Python or shell to test code
- Use Ruff for fast feedback during edits
- Require Pyright to pass before declaring changes correct

### Code Organization

- Always place python imports at top of file
- Never import packages in functions

### Principles

1. **Use `uv run python`** - Always execute Python commands via `uv run python ...` to ensure consistent dependency management and virtual environment isolation.
2. **Type hints everywhere** - Use type annotations for function signatures and variables to improve code clarity and enable better static analysis.
3. **Prefer standard library** - Use Python's standard library when possible before reaching for third-party packages. This reduces dependencies and improves portability.
4. **Explicit over implicit** - Write clear, readable code that makes intent obvious. Avoid magic methods and metaprogramming unless there's a compelling reason.

### Progress Bars

Use `tqdm` for user-facing scripts or long-running processes to provide feedback.
To keep log statements above the progress bar (preventing visual conflicts):

```python
from tqdm import tqdm

for item in tqdm(items, desc="Processing"):
    # Use tqdm.write() instead of print() for log messages
    tqdm.write(f"Processing {item.name}")
    process(item)
```

For logging module integration:

```python
import logging
from tqdm import tqdm

# Redirect logging through tqdm
class TqdmLoggingHandler(logging.Handler):
    def emit(self, record):
        tqdm.write(self.format(record))

logging.basicConfig(handlers=[TqdmLoggingHandler()], level=logging.INFO)
```

## Pandas

### Principles

1. **Use vectorized operations** - Avoid iterating over rows with `for` loops or `.iterrows()`. Use built-in vectorized methods for performance.

2. **Chain methods** - Use method chaining (`.pipe()`, `.assign()`, `.query()`) for readable, declarative transformations.

3. **Be explicit with dtypes** - Specify dtypes when reading data and use `.astype()` to enforce types. This prevents silent type coercion bugs.

4. **Prefer `.loc` and `.iloc`** - Use explicit indexing instead of chained indexing to avoid `SettingWithCopyWarning` and ensure predictable behavior.

5. **Handle missing data intentionally** - Use `.isna()`, `.fillna()`, or `.dropna()` explicitly. Never assume data is complete.

6. **Use `.copy()` when needed** - Create explicit copies when modifying subsets to avoid unintended mutations to the original DataFrame.

## Docs Style

Compact, high signal to noise write descriptions optimized for an engineer-to-engineer dialogue.

- Be concise. Prefer short sentences and direct statements.
- Focus on actionable information. Avoid filler, marketing, and verbosity.
- Use plain language and concrete terms.
- Keep sections small; remove anything nonessential.
- Use bullets for quick scanning; avoid long paragraphs.
- Favor commands/examples over prose.
- State assumptions explicitly when needed.
- Avoid redundancy.

## Pull Requests

### Pull Request Description

When opening or updating pull requests, include the following write-up in the PR body.

- Summary (required). Less than 100 words. What changed and why (not a file list)
- Features (optional). Bullet list of new behavior/capabilities, or "N/A".
- Refactoring (optional). Explain what changed and why. Describe new code structure and patterns.
- Fixes (optional). Bullet list of bugs corrected/remediation, or "N/A".
- Documentation (required if behavior changed)
- Additional notes (when applicable). Link issue(s) or external resources.
